{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Updater = void 0;\n\nconst Utils_1 = require(\"../../Utils\");\n\nconst Enums_1 = require(\"../../Enums\");\n\nclass Updater {\n  constructor(container, particle) {\n    this.container = container;\n    this.particle = particle;\n  }\n\n  update(delta) {\n    if (this.particle.destroyed) {\n      return;\n    }\n\n    this.updateOpacity(delta);\n    this.updateSize(delta);\n    this.updateAngle(delta);\n    this.updateColor(delta);\n    this.updateStrokeColor(delta);\n    this.updateOutMode(delta);\n  }\n\n  updateOpacity(delta) {\n    const particle = this.particle;\n\n    if (particle.particlesOptions.opacity.animation.enable) {\n      switch (particle.opacity.status) {\n        case Enums_1.OpacityAnimationStatus.increasing:\n          if (particle.opacity.value >= particle.particlesOptions.opacity.value) {\n            particle.opacity.status = Enums_1.OpacityAnimationStatus.decreasing;\n          } else {\n            particle.opacity.value += (particle.opacity.velocity || 0) * delta.factor;\n          }\n\n          break;\n\n        case Enums_1.OpacityAnimationStatus.decreasing:\n          if (particle.opacity.value <= particle.particlesOptions.opacity.animation.minimumValue) {\n            particle.opacity.status = Enums_1.OpacityAnimationStatus.increasing;\n          } else {\n            particle.opacity.value -= (particle.opacity.velocity || 0) * delta.factor;\n          }\n\n          break;\n      }\n\n      if (particle.opacity.value < 0) {\n        particle.opacity.value = 0;\n      }\n    }\n  }\n\n  updateSize(delta) {\n    var _a;\n\n    const container = this.container;\n    const particle = this.particle;\n    const sizeOpt = particle.particlesOptions.size;\n    const sizeAnim = sizeOpt.animation;\n\n    if (sizeAnim.enable) {\n      switch (particle.size.status) {\n        case Enums_1.SizeAnimationStatus.increasing:\n          if (particle.size.value >= ((_a = particle.sizeValue) !== null && _a !== void 0 ? _a : container.retina.sizeValue)) {\n            particle.size.status = Enums_1.SizeAnimationStatus.decreasing;\n          } else {\n            particle.size.value += (particle.size.velocity || 0) * delta.factor;\n          }\n\n          break;\n\n        case Enums_1.SizeAnimationStatus.decreasing:\n          if (particle.size.value <= sizeAnim.minimumValue) {\n            particle.size.status = Enums_1.SizeAnimationStatus.increasing;\n          } else {\n            particle.size.value -= (particle.size.velocity || 0) * delta.factor;\n          }\n\n      }\n\n      switch (sizeAnim.destroy) {\n        case Enums_1.DestroyType.max:\n          if (particle.size.value >= sizeOpt.value * container.retina.pixelRatio) {\n            particle.destroy();\n          }\n\n          break;\n\n        case Enums_1.DestroyType.min:\n          if (particle.size.value <= sizeAnim.minimumValue * container.retina.pixelRatio) {\n            particle.destroy();\n          }\n\n          break;\n      }\n\n      if (particle.size.value < 0 && !particle.destroyed) {\n        particle.size.value = 0;\n      }\n    }\n  }\n\n  updateAngle(delta) {\n    const particle = this.particle;\n    const rotate = particle.particlesOptions.rotate;\n    const rotateAnimation = rotate.animation;\n    const speed = rotateAnimation.speed / 360 * delta.factor;\n    const max = 2 * Math.PI;\n\n    if (rotate.path) {\n      particle.pathAngle = Math.atan2(particle.velocity.vertical, particle.velocity.horizontal);\n    } else {\n      if (rotateAnimation.enable) {\n        switch (particle.rotateDirection) {\n          case Enums_1.RotateDirection.clockwise:\n            particle.angle += speed;\n\n            if (particle.angle > max) {\n              particle.angle -= max;\n            }\n\n            break;\n\n          case Enums_1.RotateDirection.counterClockwise:\n          default:\n            particle.angle -= speed;\n\n            if (particle.angle < 0) {\n              particle.angle += max;\n            }\n\n            break;\n        }\n      }\n    }\n  }\n\n  updateColor(delta) {\n    const particle = this.particle;\n\n    if (particle.color === undefined) {\n      return;\n    }\n\n    if (particle.particlesOptions.color.animation.enable) {\n      particle.color.h += (particle.colorVelocity || 0) * delta.factor;\n\n      if (particle.color.h > 360) {\n        particle.color.h -= 360;\n      }\n    }\n  }\n\n  updateStrokeColor(delta) {\n    const particle = this.particle;\n    const color = particle.stroke.color;\n\n    if (typeof color === \"string\" || color === undefined) {\n      return;\n    }\n\n    if (particle.strokeColor === undefined) {\n      return;\n    }\n\n    if (color.animation.enable) {\n      particle.strokeColor.h += (particle.colorVelocity || 0) * delta.factor;\n\n      if (particle.strokeColor.h > 360) {\n        particle.strokeColor.h -= 360;\n      }\n    }\n  }\n\n  fixOutOfCanvasPosition() {\n    const container = this.container;\n    const particle = this.particle;\n    const wrap = particle.particlesOptions.move.warp;\n    const canvasSize = container.canvas.size;\n    const newPos = {\n      bottom: canvasSize.height + particle.size.value - particle.offset.y,\n      left: -particle.size.value - particle.offset.x,\n      right: canvasSize.width + particle.size.value + particle.offset.x,\n      top: -particle.size.value - particle.offset.y\n    };\n    const sizeValue = particle.size.value;\n    const nextBounds = Utils_1.Utils.calculateBounds(particle.position, sizeValue);\n\n    if (nextBounds.left > canvasSize.width - particle.offset.x) {\n      particle.position.x = newPos.left;\n\n      if (!wrap) {\n        particle.position.y = Math.random() * canvasSize.height;\n      }\n    } else if (nextBounds.right < -particle.offset.x) {\n      particle.position.x = newPos.right;\n\n      if (!wrap) {\n        particle.position.y = Math.random() * canvasSize.height;\n      }\n    }\n\n    if (nextBounds.top > canvasSize.height - particle.offset.y) {\n      if (!wrap) {\n        particle.position.x = Math.random() * canvasSize.width;\n      }\n\n      particle.position.y = newPos.top;\n    } else if (nextBounds.bottom < -particle.offset.y) {\n      if (!wrap) {\n        particle.position.x = Math.random() * canvasSize.width;\n      }\n\n      particle.position.y = newPos.bottom;\n    }\n  }\n\n  updateOutMode(delta) {\n    const container = this.container;\n    const particle = this.particle;\n\n    switch (particle.particlesOptions.move.outMode) {\n      case Enums_1.OutMode.bounce:\n      case Enums_1.OutMode.bounceVertical:\n      case Enums_1.OutMode.bounceHorizontal:\n        this.updateBounce(delta);\n        break;\n\n      case Enums_1.OutMode.destroy:\n        if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.size.value)) {\n          particle.destroy();\n          container.particles.remove(particle);\n          return;\n        }\n\n        break;\n\n      case Enums_1.OutMode.out:\n        if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.size.value)) {\n          this.fixOutOfCanvasPosition();\n        }\n\n    }\n  }\n\n  updateBounce(delta) {\n    const container = this.container;\n    const particle = this.particle;\n    let handled = false;\n\n    for (const [, plugin] of container.plugins) {\n      if (plugin.particleBounce !== undefined) {\n        handled = plugin.particleBounce(particle, delta);\n      }\n\n      if (handled) {\n        break;\n      }\n    }\n\n    if (handled) {\n      return;\n    }\n\n    const outMode = particle.particlesOptions.move.outMode,\n          pos = particle.getPosition(),\n          offset = particle.offset,\n          size = particle.size.value,\n          bounds = Utils_1.Utils.calculateBounds(pos, size),\n          canvasSize = container.canvas.size;\n\n    if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceHorizontal) {\n      const velocity = particle.velocity.horizontal;\n\n      if (bounds.right >= canvasSize.width && velocity > 0 || bounds.left <= 0 && velocity < 0) {\n        particle.velocity.horizontal *= -1;\n      }\n\n      const minPos = offset.x + size;\n\n      if (bounds.right >= canvasSize.width) {\n        particle.position.x = canvasSize.width - minPos;\n      } else if (bounds.left <= 0) {\n        particle.position.x = minPos;\n      }\n    }\n\n    if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceVertical) {\n      const velocity = particle.velocity.vertical;\n\n      if (bounds.bottom >= container.canvas.size.height && velocity > 0 || bounds.top <= 0 && velocity < 0) {\n        particle.velocity.vertical *= -1;\n      }\n\n      const minPos = offset.y + size;\n\n      if (bounds.bottom >= canvasSize.height) {\n        particle.position.y = canvasSize.height - minPos;\n      } else if (bounds.top <= 0) {\n        particle.position.y = minPos;\n      }\n    }\n  }\n\n}\n\nexports.Updater = Updater;","map":{"version":3,"names":["Object","defineProperty","exports","value","Updater","Utils_1","require","Enums_1","constructor","container","particle","update","delta","destroyed","updateOpacity","updateSize","updateAngle","updateColor","updateStrokeColor","updateOutMode","particlesOptions","opacity","animation","enable","status","OpacityAnimationStatus","increasing","decreasing","velocity","factor","minimumValue","_a","sizeOpt","size","sizeAnim","SizeAnimationStatus","sizeValue","retina","destroy","DestroyType","max","pixelRatio","min","rotate","rotateAnimation","speed","Math","PI","path","pathAngle","atan2","vertical","horizontal","rotateDirection","RotateDirection","clockwise","angle","counterClockwise","color","undefined","h","colorVelocity","stroke","strokeColor","fixOutOfCanvasPosition","wrap","move","warp","canvasSize","canvas","newPos","bottom","height","offset","y","left","x","right","width","top","nextBounds","Utils","calculateBounds","position","random","outMode","OutMode","bounce","bounceVertical","bounceHorizontal","updateBounce","isPointInside","particles","remove","out","handled","plugin","plugins","particleBounce","pos","getPosition","bounds","minPos"],"sources":["/Users/isaicastro/Desktop/Projects/Face-Recognition/node_modules/tsparticles/dist/Core/Particle/Updater.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Updater = void 0;\nconst Utils_1 = require(\"../../Utils\");\nconst Enums_1 = require(\"../../Enums\");\nclass Updater {\n    constructor(container, particle) {\n        this.container = container;\n        this.particle = particle;\n    }\n    update(delta) {\n        if (this.particle.destroyed) {\n            return;\n        }\n        this.updateOpacity(delta);\n        this.updateSize(delta);\n        this.updateAngle(delta);\n        this.updateColor(delta);\n        this.updateStrokeColor(delta);\n        this.updateOutMode(delta);\n    }\n    updateOpacity(delta) {\n        const particle = this.particle;\n        if (particle.particlesOptions.opacity.animation.enable) {\n            switch (particle.opacity.status) {\n                case Enums_1.OpacityAnimationStatus.increasing:\n                    if (particle.opacity.value >= particle.particlesOptions.opacity.value) {\n                        particle.opacity.status = Enums_1.OpacityAnimationStatus.decreasing;\n                    }\n                    else {\n                        particle.opacity.value += (particle.opacity.velocity || 0) * delta.factor;\n                    }\n                    break;\n                case Enums_1.OpacityAnimationStatus.decreasing:\n                    if (particle.opacity.value <= particle.particlesOptions.opacity.animation.minimumValue) {\n                        particle.opacity.status = Enums_1.OpacityAnimationStatus.increasing;\n                    }\n                    else {\n                        particle.opacity.value -= (particle.opacity.velocity || 0) * delta.factor;\n                    }\n                    break;\n            }\n            if (particle.opacity.value < 0) {\n                particle.opacity.value = 0;\n            }\n        }\n    }\n    updateSize(delta) {\n        var _a;\n        const container = this.container;\n        const particle = this.particle;\n        const sizeOpt = particle.particlesOptions.size;\n        const sizeAnim = sizeOpt.animation;\n        if (sizeAnim.enable) {\n            switch (particle.size.status) {\n                case Enums_1.SizeAnimationStatus.increasing:\n                    if (particle.size.value >= ((_a = particle.sizeValue) !== null && _a !== void 0 ? _a : container.retina.sizeValue)) {\n                        particle.size.status = Enums_1.SizeAnimationStatus.decreasing;\n                    }\n                    else {\n                        particle.size.value += (particle.size.velocity || 0) * delta.factor;\n                    }\n                    break;\n                case Enums_1.SizeAnimationStatus.decreasing:\n                    if (particle.size.value <= sizeAnim.minimumValue) {\n                        particle.size.status = Enums_1.SizeAnimationStatus.increasing;\n                    }\n                    else {\n                        particle.size.value -= (particle.size.velocity || 0) * delta.factor;\n                    }\n            }\n            switch (sizeAnim.destroy) {\n                case Enums_1.DestroyType.max:\n                    if (particle.size.value >= sizeOpt.value * container.retina.pixelRatio) {\n                        particle.destroy();\n                    }\n                    break;\n                case Enums_1.DestroyType.min:\n                    if (particle.size.value <= sizeAnim.minimumValue * container.retina.pixelRatio) {\n                        particle.destroy();\n                    }\n                    break;\n            }\n            if (particle.size.value < 0 && !particle.destroyed) {\n                particle.size.value = 0;\n            }\n        }\n    }\n    updateAngle(delta) {\n        const particle = this.particle;\n        const rotate = particle.particlesOptions.rotate;\n        const rotateAnimation = rotate.animation;\n        const speed = (rotateAnimation.speed / 360) * delta.factor;\n        const max = 2 * Math.PI;\n        if (rotate.path) {\n            particle.pathAngle = Math.atan2(particle.velocity.vertical, particle.velocity.horizontal);\n        }\n        else {\n            if (rotateAnimation.enable) {\n                switch (particle.rotateDirection) {\n                    case Enums_1.RotateDirection.clockwise:\n                        particle.angle += speed;\n                        if (particle.angle > max) {\n                            particle.angle -= max;\n                        }\n                        break;\n                    case Enums_1.RotateDirection.counterClockwise:\n                    default:\n                        particle.angle -= speed;\n                        if (particle.angle < 0) {\n                            particle.angle += max;\n                        }\n                        break;\n                }\n            }\n        }\n    }\n    updateColor(delta) {\n        const particle = this.particle;\n        if (particle.color === undefined) {\n            return;\n        }\n        if (particle.particlesOptions.color.animation.enable) {\n            particle.color.h += (particle.colorVelocity || 0) * delta.factor;\n            if (particle.color.h > 360) {\n                particle.color.h -= 360;\n            }\n        }\n    }\n    updateStrokeColor(delta) {\n        const particle = this.particle;\n        const color = particle.stroke.color;\n        if (typeof color === \"string\" || color === undefined) {\n            return;\n        }\n        if (particle.strokeColor === undefined) {\n            return;\n        }\n        if (color.animation.enable) {\n            particle.strokeColor.h += (particle.colorVelocity || 0) * delta.factor;\n            if (particle.strokeColor.h > 360) {\n                particle.strokeColor.h -= 360;\n            }\n        }\n    }\n    fixOutOfCanvasPosition() {\n        const container = this.container;\n        const particle = this.particle;\n        const wrap = particle.particlesOptions.move.warp;\n        const canvasSize = container.canvas.size;\n        const newPos = {\n            bottom: canvasSize.height + particle.size.value - particle.offset.y,\n            left: -particle.size.value - particle.offset.x,\n            right: canvasSize.width + particle.size.value + particle.offset.x,\n            top: -particle.size.value - particle.offset.y,\n        };\n        const sizeValue = particle.size.value;\n        const nextBounds = Utils_1.Utils.calculateBounds(particle.position, sizeValue);\n        if (nextBounds.left > canvasSize.width - particle.offset.x) {\n            particle.position.x = newPos.left;\n            if (!wrap) {\n                particle.position.y = Math.random() * canvasSize.height;\n            }\n        }\n        else if (nextBounds.right < -particle.offset.x) {\n            particle.position.x = newPos.right;\n            if (!wrap) {\n                particle.position.y = Math.random() * canvasSize.height;\n            }\n        }\n        if (nextBounds.top > canvasSize.height - particle.offset.y) {\n            if (!wrap) {\n                particle.position.x = Math.random() * canvasSize.width;\n            }\n            particle.position.y = newPos.top;\n        }\n        else if (nextBounds.bottom < -particle.offset.y) {\n            if (!wrap) {\n                particle.position.x = Math.random() * canvasSize.width;\n            }\n            particle.position.y = newPos.bottom;\n        }\n    }\n    updateOutMode(delta) {\n        const container = this.container;\n        const particle = this.particle;\n        switch (particle.particlesOptions.move.outMode) {\n            case Enums_1.OutMode.bounce:\n            case Enums_1.OutMode.bounceVertical:\n            case Enums_1.OutMode.bounceHorizontal:\n                this.updateBounce(delta);\n                break;\n            case Enums_1.OutMode.destroy:\n                if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.size.value)) {\n                    particle.destroy();\n                    container.particles.remove(particle);\n                    return;\n                }\n                break;\n            case Enums_1.OutMode.out:\n                if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.size.value)) {\n                    this.fixOutOfCanvasPosition();\n                }\n        }\n    }\n    updateBounce(delta) {\n        const container = this.container;\n        const particle = this.particle;\n        let handled = false;\n        for (const [, plugin] of container.plugins) {\n            if (plugin.particleBounce !== undefined) {\n                handled = plugin.particleBounce(particle, delta);\n            }\n            if (handled) {\n                break;\n            }\n        }\n        if (handled) {\n            return;\n        }\n        const outMode = particle.particlesOptions.move.outMode, pos = particle.getPosition(), offset = particle.offset, size = particle.size.value, bounds = Utils_1.Utils.calculateBounds(pos, size), canvasSize = container.canvas.size;\n        if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceHorizontal) {\n            const velocity = particle.velocity.horizontal;\n            if ((bounds.right >= canvasSize.width && velocity > 0) || (bounds.left <= 0 && velocity < 0)) {\n                particle.velocity.horizontal *= -1;\n            }\n            const minPos = offset.x + size;\n            if (bounds.right >= canvasSize.width) {\n                particle.position.x = canvasSize.width - minPos;\n            }\n            else if (bounds.left <= 0) {\n                particle.position.x = minPos;\n            }\n        }\n        if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceVertical) {\n            const velocity = particle.velocity.vertical;\n            if ((bounds.bottom >= container.canvas.size.height && velocity > 0) || (bounds.top <= 0 && velocity < 0)) {\n                particle.velocity.vertical *= -1;\n            }\n            const minPos = offset.y + size;\n            if (bounds.bottom >= canvasSize.height) {\n                particle.position.y = canvasSize.height - minPos;\n            }\n            else if (bounds.top <= 0) {\n                particle.position.y = minPos;\n            }\n        }\n    }\n}\nexports.Updater = Updater;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}