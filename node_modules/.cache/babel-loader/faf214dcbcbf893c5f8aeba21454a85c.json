{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CanvasUtils = void 0;\n\nconst ColorUtils_1 = require(\"./ColorUtils\");\n\nconst Utils_1 = require(\"./Utils\");\n\nclass CanvasUtils {\n  static paintBase(context, dimension, baseColor) {\n    context.save();\n    context.fillStyle = baseColor !== null && baseColor !== void 0 ? baseColor : \"rgba(0,0,0,0)\";\n    context.fillRect(0, 0, dimension.width, dimension.height);\n    context.restore();\n  }\n\n  static clear(context, dimension) {\n    context.clearRect(0, 0, dimension.width, dimension.height);\n  }\n\n  static drawLinkLine(context, width, begin, end, maxDistance, canvasSize, warp, backgroundMask, colorLine, opacity, shadow) {\n    let drawn = false;\n\n    if (Utils_1.Utils.getDistance(begin, end) <= maxDistance) {\n      this.drawLine(context, begin, end);\n      drawn = true;\n    } else if (warp) {\n      let pi1;\n      let pi2;\n      const endNE = {\n        x: end.x - canvasSize.width,\n        y: end.y\n      };\n      const {\n        dx,\n        dy,\n        distance\n      } = Utils_1.Utils.getDistances(begin, endNE);\n\n      if (distance <= maxDistance) {\n        const yi = begin.y - dy / dx * begin.x;\n        pi1 = {\n          x: 0,\n          y: yi\n        };\n        pi2 = {\n          x: canvasSize.width,\n          y: yi\n        };\n      } else {\n        const endSW = {\n          x: end.x,\n          y: end.y - canvasSize.height\n        };\n        const {\n          dx,\n          dy,\n          distance\n        } = Utils_1.Utils.getDistances(begin, endSW);\n\n        if (distance <= maxDistance) {\n          const yi = begin.y - dy / dx * begin.x;\n          const xi = -yi / (dy / dx);\n          pi1 = {\n            x: xi,\n            y: 0\n          };\n          pi2 = {\n            x: xi,\n            y: canvasSize.height\n          };\n        } else {\n          const endSE = {\n            x: end.x - canvasSize.width,\n            y: end.y - canvasSize.height\n          };\n          const {\n            dx,\n            dy,\n            distance\n          } = Utils_1.Utils.getDistances(begin, endSE);\n\n          if (distance <= maxDistance) {\n            const yi = begin.y - dy / dx * begin.x;\n            const xi = -yi / (dy / dx);\n            pi1 = {\n              x: xi,\n              y: yi\n            };\n            pi2 = {\n              x: pi1.x + canvasSize.width,\n              y: pi1.y + canvasSize.height\n            };\n          }\n        }\n      }\n\n      if (pi1 && pi2) {\n        this.drawLine(context, begin, pi1);\n        this.drawLine(context, end, pi2);\n        drawn = true;\n      }\n    }\n\n    if (!drawn) {\n      return;\n    }\n\n    context.lineWidth = width;\n\n    if (backgroundMask) {\n      context.globalCompositeOperation = \"destination-out\";\n    }\n\n    context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);\n\n    if (shadow.enable) {\n      const shadowColor = ColorUtils_1.ColorUtils.colorToRgb(shadow.color);\n\n      if (shadowColor) {\n        context.shadowBlur = shadow.blur;\n        context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);\n      }\n    }\n\n    context.stroke();\n  }\n\n  static drawLinkTriangle(context, width, pos1, pos2, pos3, backgroundMask, colorTriangle, opacityTriangle) {\n    this.drawTriangle(context, pos1, pos2, pos3);\n    context.lineWidth = width;\n\n    if (backgroundMask) {\n      context.globalCompositeOperation = \"destination-out\";\n    }\n\n    context.fillStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorTriangle, opacityTriangle);\n    context.fill();\n  }\n\n  static drawConnectLine(context, width, lineStyle, begin, end) {\n    context.save();\n    this.drawLine(context, begin, end);\n    context.lineWidth = width;\n    context.strokeStyle = lineStyle;\n    context.stroke();\n    context.restore();\n  }\n\n  static gradient(context, p1, p2, opacity) {\n    const gradStop = Math.floor(p2.size.value / p1.size.value);\n    const color1 = p1.getFillColor();\n    const color2 = p2.getFillColor();\n\n    if (!color1 || !color2) {\n      return;\n    }\n\n    const sourcePos = p1.getPosition();\n    const destPos = p2.getPosition();\n    const midRgb = ColorUtils_1.ColorUtils.mix(color1, color2, p1.size.value, p2.size.value);\n    const grad = context.createLinearGradient(sourcePos.x, sourcePos.y, destPos.x, destPos.y);\n    grad.addColorStop(0, ColorUtils_1.ColorUtils.getStyleFromHsl(color1, opacity));\n    grad.addColorStop(gradStop > 1 ? 1 : gradStop, ColorUtils_1.ColorUtils.getStyleFromRgb(midRgb, opacity));\n    grad.addColorStop(1, ColorUtils_1.ColorUtils.getStyleFromHsl(color2, opacity));\n    return grad;\n  }\n\n  static drawGrabLine(context, width, begin, end, colorLine, opacity) {\n    context.save();\n    this.drawLine(context, begin, end);\n    context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);\n    context.lineWidth = width;\n    context.stroke();\n    context.restore();\n  }\n\n  static drawParticle(container, context, particle, delta, fillColorValue, strokeColorValue, backgroundMask, radius, opacity, shadow) {\n    const pos = particle.getPosition();\n    context.save();\n    context.translate(pos.x, pos.y);\n    context.beginPath();\n    const angle = particle.angle + (particle.particlesOptions.rotate.path ? particle.pathAngle : 0);\n\n    if (angle !== 0) {\n      context.rotate(angle);\n    }\n\n    if (backgroundMask) {\n      context.globalCompositeOperation = \"destination-out\";\n    }\n\n    const shadowColor = particle.shadowColor;\n\n    if (shadow.enable && shadowColor) {\n      context.shadowBlur = shadow.blur;\n      context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);\n      context.shadowOffsetX = shadow.offset.x;\n      context.shadowOffsetY = shadow.offset.y;\n    }\n\n    context.fillStyle = fillColorValue;\n    const stroke = particle.stroke;\n    context.lineWidth = particle.strokeWidth;\n    context.strokeStyle = strokeColorValue;\n\n    if (particle.close) {\n      context.closePath();\n    }\n\n    this.drawShape(container, context, particle, radius, opacity, delta);\n\n    if (stroke.width > 0) {\n      context.stroke();\n    }\n\n    if (particle.fill) {\n      context.fill();\n    }\n\n    context.restore();\n    context.save();\n    context.translate(pos.x, pos.y);\n\n    if (particle.angle !== 0) {\n      context.rotate(particle.angle);\n    }\n\n    if (backgroundMask) {\n      context.globalCompositeOperation = \"destination-out\";\n    }\n\n    this.drawShapeAfterEffect(container, context, particle, radius, opacity, delta);\n    context.restore();\n  }\n\n  static drawShape(container, context, particle, radius, opacity, delta) {\n    if (!particle.shape) {\n      return;\n    }\n\n    const drawer = container.drawers.get(particle.shape);\n\n    if (!drawer) {\n      return;\n    }\n\n    drawer.draw(context, particle, radius, opacity, delta.value, container.retina.pixelRatio);\n  }\n\n  static drawShapeAfterEffect(container, context, particle, radius, opacity, delta) {\n    if (!particle.shape) {\n      return;\n    }\n\n    const drawer = container.drawers.get(particle.shape);\n\n    if (!(drawer === null || drawer === void 0 ? void 0 : drawer.afterEffect)) {\n      return;\n    }\n\n    drawer.afterEffect(context, particle, radius, opacity, delta.value, container.retina.pixelRatio);\n  }\n\n  static drawPlugin(context, plugin, delta) {\n    if (plugin.draw !== undefined) {\n      context.save();\n      plugin.draw(context, delta);\n      context.restore();\n    }\n  }\n\n  static drawLine(context, begin, end) {\n    context.beginPath();\n    context.moveTo(begin.x, begin.y);\n    context.lineTo(end.x, end.y);\n    context.closePath();\n  }\n\n  static drawTriangle(context, p1, p2, p3) {\n    context.beginPath();\n    context.moveTo(p1.x, p1.y);\n    context.lineTo(p2.x, p2.y);\n    context.lineTo(p3.x, p3.y);\n    context.closePath();\n  }\n\n}\n\nexports.CanvasUtils = CanvasUtils;","map":{"version":3,"names":["Object","defineProperty","exports","value","CanvasUtils","ColorUtils_1","require","Utils_1","paintBase","context","dimension","baseColor","save","fillStyle","fillRect","width","height","restore","clear","clearRect","drawLinkLine","begin","end","maxDistance","canvasSize","warp","backgroundMask","colorLine","opacity","shadow","drawn","Utils","getDistance","drawLine","pi1","pi2","endNE","x","y","dx","dy","distance","getDistances","yi","endSW","xi","endSE","lineWidth","globalCompositeOperation","strokeStyle","ColorUtils","getStyleFromRgb","enable","shadowColor","colorToRgb","color","shadowBlur","blur","stroke","drawLinkTriangle","pos1","pos2","pos3","colorTriangle","opacityTriangle","drawTriangle","fill","drawConnectLine","lineStyle","gradient","p1","p2","gradStop","Math","floor","size","color1","getFillColor","color2","sourcePos","getPosition","destPos","midRgb","mix","grad","createLinearGradient","addColorStop","getStyleFromHsl","drawGrabLine","drawParticle","container","particle","delta","fillColorValue","strokeColorValue","radius","pos","translate","beginPath","angle","particlesOptions","rotate","path","pathAngle","shadowOffsetX","offset","shadowOffsetY","strokeWidth","close","closePath","drawShape","drawShapeAfterEffect","shape","drawer","drawers","get","draw","retina","pixelRatio","afterEffect","drawPlugin","plugin","undefined","moveTo","lineTo","p3"],"sources":["/Users/isaicastro/Desktop/Projects/Face-Recognition/node_modules/tsparticles/dist/Utils/CanvasUtils.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CanvasUtils = void 0;\nconst ColorUtils_1 = require(\"./ColorUtils\");\nconst Utils_1 = require(\"./Utils\");\nclass CanvasUtils {\n    static paintBase(context, dimension, baseColor) {\n        context.save();\n        context.fillStyle = baseColor !== null && baseColor !== void 0 ? baseColor : \"rgba(0,0,0,0)\";\n        context.fillRect(0, 0, dimension.width, dimension.height);\n        context.restore();\n    }\n    static clear(context, dimension) {\n        context.clearRect(0, 0, dimension.width, dimension.height);\n    }\n    static drawLinkLine(context, width, begin, end, maxDistance, canvasSize, warp, backgroundMask, colorLine, opacity, shadow) {\n        let drawn = false;\n        if (Utils_1.Utils.getDistance(begin, end) <= maxDistance) {\n            this.drawLine(context, begin, end);\n            drawn = true;\n        }\n        else if (warp) {\n            let pi1;\n            let pi2;\n            const endNE = {\n                x: end.x - canvasSize.width,\n                y: end.y,\n            };\n            const { dx, dy, distance } = Utils_1.Utils.getDistances(begin, endNE);\n            if (distance <= maxDistance) {\n                const yi = begin.y - (dy / dx) * begin.x;\n                pi1 = { x: 0, y: yi };\n                pi2 = { x: canvasSize.width, y: yi };\n            }\n            else {\n                const endSW = {\n                    x: end.x,\n                    y: end.y - canvasSize.height,\n                };\n                const { dx, dy, distance } = Utils_1.Utils.getDistances(begin, endSW);\n                if (distance <= maxDistance) {\n                    const yi = begin.y - (dy / dx) * begin.x;\n                    const xi = -yi / (dy / dx);\n                    pi1 = { x: xi, y: 0 };\n                    pi2 = { x: xi, y: canvasSize.height };\n                }\n                else {\n                    const endSE = {\n                        x: end.x - canvasSize.width,\n                        y: end.y - canvasSize.height,\n                    };\n                    const { dx, dy, distance } = Utils_1.Utils.getDistances(begin, endSE);\n                    if (distance <= maxDistance) {\n                        const yi = begin.y - (dy / dx) * begin.x;\n                        const xi = -yi / (dy / dx);\n                        pi1 = { x: xi, y: yi };\n                        pi2 = { x: pi1.x + canvasSize.width, y: pi1.y + canvasSize.height };\n                    }\n                }\n            }\n            if (pi1 && pi2) {\n                this.drawLine(context, begin, pi1);\n                this.drawLine(context, end, pi2);\n                drawn = true;\n            }\n        }\n        if (!drawn) {\n            return;\n        }\n        context.lineWidth = width;\n        if (backgroundMask) {\n            context.globalCompositeOperation = \"destination-out\";\n        }\n        context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);\n        if (shadow.enable) {\n            const shadowColor = ColorUtils_1.ColorUtils.colorToRgb(shadow.color);\n            if (shadowColor) {\n                context.shadowBlur = shadow.blur;\n                context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);\n            }\n        }\n        context.stroke();\n    }\n    static drawLinkTriangle(context, width, pos1, pos2, pos3, backgroundMask, colorTriangle, opacityTriangle) {\n        this.drawTriangle(context, pos1, pos2, pos3);\n        context.lineWidth = width;\n        if (backgroundMask) {\n            context.globalCompositeOperation = \"destination-out\";\n        }\n        context.fillStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorTriangle, opacityTriangle);\n        context.fill();\n    }\n    static drawConnectLine(context, width, lineStyle, begin, end) {\n        context.save();\n        this.drawLine(context, begin, end);\n        context.lineWidth = width;\n        context.strokeStyle = lineStyle;\n        context.stroke();\n        context.restore();\n    }\n    static gradient(context, p1, p2, opacity) {\n        const gradStop = Math.floor(p2.size.value / p1.size.value);\n        const color1 = p1.getFillColor();\n        const color2 = p2.getFillColor();\n        if (!color1 || !color2) {\n            return;\n        }\n        const sourcePos = p1.getPosition();\n        const destPos = p2.getPosition();\n        const midRgb = ColorUtils_1.ColorUtils.mix(color1, color2, p1.size.value, p2.size.value);\n        const grad = context.createLinearGradient(sourcePos.x, sourcePos.y, destPos.x, destPos.y);\n        grad.addColorStop(0, ColorUtils_1.ColorUtils.getStyleFromHsl(color1, opacity));\n        grad.addColorStop(gradStop > 1 ? 1 : gradStop, ColorUtils_1.ColorUtils.getStyleFromRgb(midRgb, opacity));\n        grad.addColorStop(1, ColorUtils_1.ColorUtils.getStyleFromHsl(color2, opacity));\n        return grad;\n    }\n    static drawGrabLine(context, width, begin, end, colorLine, opacity) {\n        context.save();\n        this.drawLine(context, begin, end);\n        context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);\n        context.lineWidth = width;\n        context.stroke();\n        context.restore();\n    }\n    static drawParticle(container, context, particle, delta, fillColorValue, strokeColorValue, backgroundMask, radius, opacity, shadow) {\n        const pos = particle.getPosition();\n        context.save();\n        context.translate(pos.x, pos.y);\n        context.beginPath();\n        const angle = particle.angle + (particle.particlesOptions.rotate.path ? particle.pathAngle : 0);\n        if (angle !== 0) {\n            context.rotate(angle);\n        }\n        if (backgroundMask) {\n            context.globalCompositeOperation = \"destination-out\";\n        }\n        const shadowColor = particle.shadowColor;\n        if (shadow.enable && shadowColor) {\n            context.shadowBlur = shadow.blur;\n            context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);\n            context.shadowOffsetX = shadow.offset.x;\n            context.shadowOffsetY = shadow.offset.y;\n        }\n        context.fillStyle = fillColorValue;\n        const stroke = particle.stroke;\n        context.lineWidth = particle.strokeWidth;\n        context.strokeStyle = strokeColorValue;\n        if (particle.close) {\n            context.closePath();\n        }\n        this.drawShape(container, context, particle, radius, opacity, delta);\n        if (stroke.width > 0) {\n            context.stroke();\n        }\n        if (particle.fill) {\n            context.fill();\n        }\n        context.restore();\n        context.save();\n        context.translate(pos.x, pos.y);\n        if (particle.angle !== 0) {\n            context.rotate(particle.angle);\n        }\n        if (backgroundMask) {\n            context.globalCompositeOperation = \"destination-out\";\n        }\n        this.drawShapeAfterEffect(container, context, particle, radius, opacity, delta);\n        context.restore();\n    }\n    static drawShape(container, context, particle, radius, opacity, delta) {\n        if (!particle.shape) {\n            return;\n        }\n        const drawer = container.drawers.get(particle.shape);\n        if (!drawer) {\n            return;\n        }\n        drawer.draw(context, particle, radius, opacity, delta.value, container.retina.pixelRatio);\n    }\n    static drawShapeAfterEffect(container, context, particle, radius, opacity, delta) {\n        if (!particle.shape) {\n            return;\n        }\n        const drawer = container.drawers.get(particle.shape);\n        if (!(drawer === null || drawer === void 0 ? void 0 : drawer.afterEffect)) {\n            return;\n        }\n        drawer.afterEffect(context, particle, radius, opacity, delta.value, container.retina.pixelRatio);\n    }\n    static drawPlugin(context, plugin, delta) {\n        if (plugin.draw !== undefined) {\n            context.save();\n            plugin.draw(context, delta);\n            context.restore();\n        }\n    }\n    static drawLine(context, begin, end) {\n        context.beginPath();\n        context.moveTo(begin.x, begin.y);\n        context.lineTo(end.x, end.y);\n        context.closePath();\n    }\n    static drawTriangle(context, p1, p2, p3) {\n        context.beginPath();\n        context.moveTo(p1.x, p1.y);\n        context.lineTo(p2.x, p2.y);\n        context.lineTo(p3.x, p3.y);\n        context.closePath();\n    }\n}\nexports.CanvasUtils = CanvasUtils;\n"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,WAAR,GAAsB,KAAK,CAA3B;;AACA,MAAMC,YAAY,GAAGC,OAAO,CAAC,cAAD,CAA5B;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAMF,WAAN,CAAkB;EACE,OAATI,SAAS,CAACC,OAAD,EAAUC,SAAV,EAAqBC,SAArB,EAAgC;IAC5CF,OAAO,CAACG,IAAR;IACAH,OAAO,CAACI,SAAR,GAAoBF,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAK,KAAK,CAAzC,GAA6CA,SAA7C,GAAyD,eAA7E;IACAF,OAAO,CAACK,QAAR,CAAiB,CAAjB,EAAoB,CAApB,EAAuBJ,SAAS,CAACK,KAAjC,EAAwCL,SAAS,CAACM,MAAlD;IACAP,OAAO,CAACQ,OAAR;EACH;;EACW,OAALC,KAAK,CAACT,OAAD,EAAUC,SAAV,EAAqB;IAC7BD,OAAO,CAACU,SAAR,CAAkB,CAAlB,EAAqB,CAArB,EAAwBT,SAAS,CAACK,KAAlC,EAAyCL,SAAS,CAACM,MAAnD;EACH;;EACkB,OAAZI,YAAY,CAACX,OAAD,EAAUM,KAAV,EAAiBM,KAAjB,EAAwBC,GAAxB,EAA6BC,WAA7B,EAA0CC,UAA1C,EAAsDC,IAAtD,EAA4DC,cAA5D,EAA4EC,SAA5E,EAAuFC,OAAvF,EAAgGC,MAAhG,EAAwG;IACvH,IAAIC,KAAK,GAAG,KAAZ;;IACA,IAAIvB,OAAO,CAACwB,KAAR,CAAcC,WAAd,CAA0BX,KAA1B,EAAiCC,GAAjC,KAAyCC,WAA7C,EAA0D;MACtD,KAAKU,QAAL,CAAcxB,OAAd,EAAuBY,KAAvB,EAA8BC,GAA9B;MACAQ,KAAK,GAAG,IAAR;IACH,CAHD,MAIK,IAAIL,IAAJ,EAAU;MACX,IAAIS,GAAJ;MACA,IAAIC,GAAJ;MACA,MAAMC,KAAK,GAAG;QACVC,CAAC,EAAEf,GAAG,CAACe,CAAJ,GAAQb,UAAU,CAACT,KADZ;QAEVuB,CAAC,EAAEhB,GAAG,CAACgB;MAFG,CAAd;MAIA,MAAM;QAAEC,EAAF;QAAMC,EAAN;QAAUC;MAAV,IAAuBlC,OAAO,CAACwB,KAAR,CAAcW,YAAd,CAA2BrB,KAA3B,EAAkCe,KAAlC,CAA7B;;MACA,IAAIK,QAAQ,IAAIlB,WAAhB,EAA6B;QACzB,MAAMoB,EAAE,GAAGtB,KAAK,CAACiB,CAAN,GAAWE,EAAE,GAAGD,EAAN,GAAYlB,KAAK,CAACgB,CAAvC;QACAH,GAAG,GAAG;UAAEG,CAAC,EAAE,CAAL;UAAQC,CAAC,EAAEK;QAAX,CAAN;QACAR,GAAG,GAAG;UAAEE,CAAC,EAAEb,UAAU,CAACT,KAAhB;UAAuBuB,CAAC,EAAEK;QAA1B,CAAN;MACH,CAJD,MAKK;QACD,MAAMC,KAAK,GAAG;UACVP,CAAC,EAAEf,GAAG,CAACe,CADG;UAEVC,CAAC,EAAEhB,GAAG,CAACgB,CAAJ,GAAQd,UAAU,CAACR;QAFZ,CAAd;QAIA,MAAM;UAAEuB,EAAF;UAAMC,EAAN;UAAUC;QAAV,IAAuBlC,OAAO,CAACwB,KAAR,CAAcW,YAAd,CAA2BrB,KAA3B,EAAkCuB,KAAlC,CAA7B;;QACA,IAAIH,QAAQ,IAAIlB,WAAhB,EAA6B;UACzB,MAAMoB,EAAE,GAAGtB,KAAK,CAACiB,CAAN,GAAWE,EAAE,GAAGD,EAAN,GAAYlB,KAAK,CAACgB,CAAvC;UACA,MAAMQ,EAAE,GAAG,CAACF,EAAD,IAAOH,EAAE,GAAGD,EAAZ,CAAX;UACAL,GAAG,GAAG;YAAEG,CAAC,EAAEQ,EAAL;YAASP,CAAC,EAAE;UAAZ,CAAN;UACAH,GAAG,GAAG;YAAEE,CAAC,EAAEQ,EAAL;YAASP,CAAC,EAAEd,UAAU,CAACR;UAAvB,CAAN;QACH,CALD,MAMK;UACD,MAAM8B,KAAK,GAAG;YACVT,CAAC,EAAEf,GAAG,CAACe,CAAJ,GAAQb,UAAU,CAACT,KADZ;YAEVuB,CAAC,EAAEhB,GAAG,CAACgB,CAAJ,GAAQd,UAAU,CAACR;UAFZ,CAAd;UAIA,MAAM;YAAEuB,EAAF;YAAMC,EAAN;YAAUC;UAAV,IAAuBlC,OAAO,CAACwB,KAAR,CAAcW,YAAd,CAA2BrB,KAA3B,EAAkCyB,KAAlC,CAA7B;;UACA,IAAIL,QAAQ,IAAIlB,WAAhB,EAA6B;YACzB,MAAMoB,EAAE,GAAGtB,KAAK,CAACiB,CAAN,GAAWE,EAAE,GAAGD,EAAN,GAAYlB,KAAK,CAACgB,CAAvC;YACA,MAAMQ,EAAE,GAAG,CAACF,EAAD,IAAOH,EAAE,GAAGD,EAAZ,CAAX;YACAL,GAAG,GAAG;cAAEG,CAAC,EAAEQ,EAAL;cAASP,CAAC,EAAEK;YAAZ,CAAN;YACAR,GAAG,GAAG;cAAEE,CAAC,EAAEH,GAAG,CAACG,CAAJ,GAAQb,UAAU,CAACT,KAAxB;cAA+BuB,CAAC,EAAEJ,GAAG,CAACI,CAAJ,GAAQd,UAAU,CAACR;YAArD,CAAN;UACH;QACJ;MACJ;;MACD,IAAIkB,GAAG,IAAIC,GAAX,EAAgB;QACZ,KAAKF,QAAL,CAAcxB,OAAd,EAAuBY,KAAvB,EAA8Ba,GAA9B;QACA,KAAKD,QAAL,CAAcxB,OAAd,EAAuBa,GAAvB,EAA4Ba,GAA5B;QACAL,KAAK,GAAG,IAAR;MACH;IACJ;;IACD,IAAI,CAACA,KAAL,EAAY;MACR;IACH;;IACDrB,OAAO,CAACsC,SAAR,GAAoBhC,KAApB;;IACA,IAAIW,cAAJ,EAAoB;MAChBjB,OAAO,CAACuC,wBAAR,GAAmC,iBAAnC;IACH;;IACDvC,OAAO,CAACwC,WAAR,GAAsB5C,YAAY,CAAC6C,UAAb,CAAwBC,eAAxB,CAAwCxB,SAAxC,EAAmDC,OAAnD,CAAtB;;IACA,IAAIC,MAAM,CAACuB,MAAX,EAAmB;MACf,MAAMC,WAAW,GAAGhD,YAAY,CAAC6C,UAAb,CAAwBI,UAAxB,CAAmCzB,MAAM,CAAC0B,KAA1C,CAApB;;MACA,IAAIF,WAAJ,EAAiB;QACb5C,OAAO,CAAC+C,UAAR,GAAqB3B,MAAM,CAAC4B,IAA5B;QACAhD,OAAO,CAAC4C,WAAR,GAAsBhD,YAAY,CAAC6C,UAAb,CAAwBC,eAAxB,CAAwCE,WAAxC,CAAtB;MACH;IACJ;;IACD5C,OAAO,CAACiD,MAAR;EACH;;EACsB,OAAhBC,gBAAgB,CAAClD,OAAD,EAAUM,KAAV,EAAiB6C,IAAjB,EAAuBC,IAAvB,EAA6BC,IAA7B,EAAmCpC,cAAnC,EAAmDqC,aAAnD,EAAkEC,eAAlE,EAAmF;IACtG,KAAKC,YAAL,CAAkBxD,OAAlB,EAA2BmD,IAA3B,EAAiCC,IAAjC,EAAuCC,IAAvC;IACArD,OAAO,CAACsC,SAAR,GAAoBhC,KAApB;;IACA,IAAIW,cAAJ,EAAoB;MAChBjB,OAAO,CAACuC,wBAAR,GAAmC,iBAAnC;IACH;;IACDvC,OAAO,CAACI,SAAR,GAAoBR,YAAY,CAAC6C,UAAb,CAAwBC,eAAxB,CAAwCY,aAAxC,EAAuDC,eAAvD,CAApB;IACAvD,OAAO,CAACyD,IAAR;EACH;;EACqB,OAAfC,eAAe,CAAC1D,OAAD,EAAUM,KAAV,EAAiBqD,SAAjB,EAA4B/C,KAA5B,EAAmCC,GAAnC,EAAwC;IAC1Db,OAAO,CAACG,IAAR;IACA,KAAKqB,QAAL,CAAcxB,OAAd,EAAuBY,KAAvB,EAA8BC,GAA9B;IACAb,OAAO,CAACsC,SAAR,GAAoBhC,KAApB;IACAN,OAAO,CAACwC,WAAR,GAAsBmB,SAAtB;IACA3D,OAAO,CAACiD,MAAR;IACAjD,OAAO,CAACQ,OAAR;EACH;;EACc,OAARoD,QAAQ,CAAC5D,OAAD,EAAU6D,EAAV,EAAcC,EAAd,EAAkB3C,OAAlB,EAA2B;IACtC,MAAM4C,QAAQ,GAAGC,IAAI,CAACC,KAAL,CAAWH,EAAE,CAACI,IAAH,CAAQxE,KAAR,GAAgBmE,EAAE,CAACK,IAAH,CAAQxE,KAAnC,CAAjB;IACA,MAAMyE,MAAM,GAAGN,EAAE,CAACO,YAAH,EAAf;IACA,MAAMC,MAAM,GAAGP,EAAE,CAACM,YAAH,EAAf;;IACA,IAAI,CAACD,MAAD,IAAW,CAACE,MAAhB,EAAwB;MACpB;IACH;;IACD,MAAMC,SAAS,GAAGT,EAAE,CAACU,WAAH,EAAlB;IACA,MAAMC,OAAO,GAAGV,EAAE,CAACS,WAAH,EAAhB;IACA,MAAME,MAAM,GAAG7E,YAAY,CAAC6C,UAAb,CAAwBiC,GAAxB,CAA4BP,MAA5B,EAAoCE,MAApC,EAA4CR,EAAE,CAACK,IAAH,CAAQxE,KAApD,EAA2DoE,EAAE,CAACI,IAAH,CAAQxE,KAAnE,CAAf;IACA,MAAMiF,IAAI,GAAG3E,OAAO,CAAC4E,oBAAR,CAA6BN,SAAS,CAAC1C,CAAvC,EAA0C0C,SAAS,CAACzC,CAApD,EAAuD2C,OAAO,CAAC5C,CAA/D,EAAkE4C,OAAO,CAAC3C,CAA1E,CAAb;IACA8C,IAAI,CAACE,YAAL,CAAkB,CAAlB,EAAqBjF,YAAY,CAAC6C,UAAb,CAAwBqC,eAAxB,CAAwCX,MAAxC,EAAgDhD,OAAhD,CAArB;IACAwD,IAAI,CAACE,YAAL,CAAkBd,QAAQ,GAAG,CAAX,GAAe,CAAf,GAAmBA,QAArC,EAA+CnE,YAAY,CAAC6C,UAAb,CAAwBC,eAAxB,CAAwC+B,MAAxC,EAAgDtD,OAAhD,CAA/C;IACAwD,IAAI,CAACE,YAAL,CAAkB,CAAlB,EAAqBjF,YAAY,CAAC6C,UAAb,CAAwBqC,eAAxB,CAAwCT,MAAxC,EAAgDlD,OAAhD,CAArB;IACA,OAAOwD,IAAP;EACH;;EACkB,OAAZI,YAAY,CAAC/E,OAAD,EAAUM,KAAV,EAAiBM,KAAjB,EAAwBC,GAAxB,EAA6BK,SAA7B,EAAwCC,OAAxC,EAAiD;IAChEnB,OAAO,CAACG,IAAR;IACA,KAAKqB,QAAL,CAAcxB,OAAd,EAAuBY,KAAvB,EAA8BC,GAA9B;IACAb,OAAO,CAACwC,WAAR,GAAsB5C,YAAY,CAAC6C,UAAb,CAAwBC,eAAxB,CAAwCxB,SAAxC,EAAmDC,OAAnD,CAAtB;IACAnB,OAAO,CAACsC,SAAR,GAAoBhC,KAApB;IACAN,OAAO,CAACiD,MAAR;IACAjD,OAAO,CAACQ,OAAR;EACH;;EACkB,OAAZwE,YAAY,CAACC,SAAD,EAAYjF,OAAZ,EAAqBkF,QAArB,EAA+BC,KAA/B,EAAsCC,cAAtC,EAAsDC,gBAAtD,EAAwEpE,cAAxE,EAAwFqE,MAAxF,EAAgGnE,OAAhG,EAAyGC,MAAzG,EAAiH;IAChI,MAAMmE,GAAG,GAAGL,QAAQ,CAACX,WAAT,EAAZ;IACAvE,OAAO,CAACG,IAAR;IACAH,OAAO,CAACwF,SAAR,CAAkBD,GAAG,CAAC3D,CAAtB,EAAyB2D,GAAG,CAAC1D,CAA7B;IACA7B,OAAO,CAACyF,SAAR;IACA,MAAMC,KAAK,GAAGR,QAAQ,CAACQ,KAAT,IAAkBR,QAAQ,CAACS,gBAAT,CAA0BC,MAA1B,CAAiCC,IAAjC,GAAwCX,QAAQ,CAACY,SAAjD,GAA6D,CAA/E,CAAd;;IACA,IAAIJ,KAAK,KAAK,CAAd,EAAiB;MACb1F,OAAO,CAAC4F,MAAR,CAAeF,KAAf;IACH;;IACD,IAAIzE,cAAJ,EAAoB;MAChBjB,OAAO,CAACuC,wBAAR,GAAmC,iBAAnC;IACH;;IACD,MAAMK,WAAW,GAAGsC,QAAQ,CAACtC,WAA7B;;IACA,IAAIxB,MAAM,CAACuB,MAAP,IAAiBC,WAArB,EAAkC;MAC9B5C,OAAO,CAAC+C,UAAR,GAAqB3B,MAAM,CAAC4B,IAA5B;MACAhD,OAAO,CAAC4C,WAAR,GAAsBhD,YAAY,CAAC6C,UAAb,CAAwBC,eAAxB,CAAwCE,WAAxC,CAAtB;MACA5C,OAAO,CAAC+F,aAAR,GAAwB3E,MAAM,CAAC4E,MAAP,CAAcpE,CAAtC;MACA5B,OAAO,CAACiG,aAAR,GAAwB7E,MAAM,CAAC4E,MAAP,CAAcnE,CAAtC;IACH;;IACD7B,OAAO,CAACI,SAAR,GAAoBgF,cAApB;IACA,MAAMnC,MAAM,GAAGiC,QAAQ,CAACjC,MAAxB;IACAjD,OAAO,CAACsC,SAAR,GAAoB4C,QAAQ,CAACgB,WAA7B;IACAlG,OAAO,CAACwC,WAAR,GAAsB6C,gBAAtB;;IACA,IAAIH,QAAQ,CAACiB,KAAb,EAAoB;MAChBnG,OAAO,CAACoG,SAAR;IACH;;IACD,KAAKC,SAAL,CAAepB,SAAf,EAA0BjF,OAA1B,EAAmCkF,QAAnC,EAA6CI,MAA7C,EAAqDnE,OAArD,EAA8DgE,KAA9D;;IACA,IAAIlC,MAAM,CAAC3C,KAAP,GAAe,CAAnB,EAAsB;MAClBN,OAAO,CAACiD,MAAR;IACH;;IACD,IAAIiC,QAAQ,CAACzB,IAAb,EAAmB;MACfzD,OAAO,CAACyD,IAAR;IACH;;IACDzD,OAAO,CAACQ,OAAR;IACAR,OAAO,CAACG,IAAR;IACAH,OAAO,CAACwF,SAAR,CAAkBD,GAAG,CAAC3D,CAAtB,EAAyB2D,GAAG,CAAC1D,CAA7B;;IACA,IAAIqD,QAAQ,CAACQ,KAAT,KAAmB,CAAvB,EAA0B;MACtB1F,OAAO,CAAC4F,MAAR,CAAeV,QAAQ,CAACQ,KAAxB;IACH;;IACD,IAAIzE,cAAJ,EAAoB;MAChBjB,OAAO,CAACuC,wBAAR,GAAmC,iBAAnC;IACH;;IACD,KAAK+D,oBAAL,CAA0BrB,SAA1B,EAAqCjF,OAArC,EAA8CkF,QAA9C,EAAwDI,MAAxD,EAAgEnE,OAAhE,EAAyEgE,KAAzE;IACAnF,OAAO,CAACQ,OAAR;EACH;;EACe,OAAT6F,SAAS,CAACpB,SAAD,EAAYjF,OAAZ,EAAqBkF,QAArB,EAA+BI,MAA/B,EAAuCnE,OAAvC,EAAgDgE,KAAhD,EAAuD;IACnE,IAAI,CAACD,QAAQ,CAACqB,KAAd,EAAqB;MACjB;IACH;;IACD,MAAMC,MAAM,GAAGvB,SAAS,CAACwB,OAAV,CAAkBC,GAAlB,CAAsBxB,QAAQ,CAACqB,KAA/B,CAAf;;IACA,IAAI,CAACC,MAAL,EAAa;MACT;IACH;;IACDA,MAAM,CAACG,IAAP,CAAY3G,OAAZ,EAAqBkF,QAArB,EAA+BI,MAA/B,EAAuCnE,OAAvC,EAAgDgE,KAAK,CAACzF,KAAtD,EAA6DuF,SAAS,CAAC2B,MAAV,CAAiBC,UAA9E;EACH;;EAC0B,OAApBP,oBAAoB,CAACrB,SAAD,EAAYjF,OAAZ,EAAqBkF,QAArB,EAA+BI,MAA/B,EAAuCnE,OAAvC,EAAgDgE,KAAhD,EAAuD;IAC9E,IAAI,CAACD,QAAQ,CAACqB,KAAd,EAAqB;MACjB;IACH;;IACD,MAAMC,MAAM,GAAGvB,SAAS,CAACwB,OAAV,CAAkBC,GAAlB,CAAsBxB,QAAQ,CAACqB,KAA/B,CAAf;;IACA,IAAI,EAAEC,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAK,KAAK,CAAnC,GAAuC,KAAK,CAA5C,GAAgDA,MAAM,CAACM,WAAzD,CAAJ,EAA2E;MACvE;IACH;;IACDN,MAAM,CAACM,WAAP,CAAmB9G,OAAnB,EAA4BkF,QAA5B,EAAsCI,MAAtC,EAA8CnE,OAA9C,EAAuDgE,KAAK,CAACzF,KAA7D,EAAoEuF,SAAS,CAAC2B,MAAV,CAAiBC,UAArF;EACH;;EACgB,OAAVE,UAAU,CAAC/G,OAAD,EAAUgH,MAAV,EAAkB7B,KAAlB,EAAyB;IACtC,IAAI6B,MAAM,CAACL,IAAP,KAAgBM,SAApB,EAA+B;MAC3BjH,OAAO,CAACG,IAAR;MACA6G,MAAM,CAACL,IAAP,CAAY3G,OAAZ,EAAqBmF,KAArB;MACAnF,OAAO,CAACQ,OAAR;IACH;EACJ;;EACc,OAARgB,QAAQ,CAACxB,OAAD,EAAUY,KAAV,EAAiBC,GAAjB,EAAsB;IACjCb,OAAO,CAACyF,SAAR;IACAzF,OAAO,CAACkH,MAAR,CAAetG,KAAK,CAACgB,CAArB,EAAwBhB,KAAK,CAACiB,CAA9B;IACA7B,OAAO,CAACmH,MAAR,CAAetG,GAAG,CAACe,CAAnB,EAAsBf,GAAG,CAACgB,CAA1B;IACA7B,OAAO,CAACoG,SAAR;EACH;;EACkB,OAAZ5C,YAAY,CAACxD,OAAD,EAAU6D,EAAV,EAAcC,EAAd,EAAkBsD,EAAlB,EAAsB;IACrCpH,OAAO,CAACyF,SAAR;IACAzF,OAAO,CAACkH,MAAR,CAAerD,EAAE,CAACjC,CAAlB,EAAqBiC,EAAE,CAAChC,CAAxB;IACA7B,OAAO,CAACmH,MAAR,CAAerD,EAAE,CAAClC,CAAlB,EAAqBkC,EAAE,CAACjC,CAAxB;IACA7B,OAAO,CAACmH,MAAR,CAAeC,EAAE,CAACxF,CAAlB,EAAqBwF,EAAE,CAACvF,CAAxB;IACA7B,OAAO,CAACoG,SAAR;EACH;;AA3Ma;;AA6MlB3G,OAAO,CAACE,WAAR,GAAsBA,WAAtB"},"metadata":{},"sourceType":"script"}